程序和进程的概念:
	程序: 是编译好的二进制文件, 存放在磁盘上, 占用的是磁盘空间, 是一个静态的概念.
	进程: 一个启动的程序, 需要占用系统资源: 如 内存, cpu 终端 等
	剧本--->程序
	进程--->唱戏(舞台, 灯光, 道具, 人等资源)
	同一个程序可以在多个终端执行, 类似与同一台戏可以在多个舞台演出.
	没启动一个程序都会有一个进程PID, 即使是相同的程序多次启动也会有个不同的PID.

并行和并发的概念:
	并发: 在一个时间段内, 一个CPU上, 有多个程序在执行.
	并行: 在一个时间片内, 有多个程序在执行(前提是有多个cpu)
	cpu会将一个大的时间段分成多个小的时间片, 让进程轮流使用CPU的时间片.


父子进程不能共享全局变量.

如果想在一个进程内部执行系统命令或者是应用程序, 优先应该想到如下方式:
先fork(), 然后在子进程里面执行execl拉起可执行程序或者命令.
pid = fork();
if(pid==0)
{
	execl(...);
}

execl: 一般用于执行用户自定义的应用程序.
execp: 一般用于执行系统命令

孤儿进程: 父进程先退出, 子进程就变成了孤儿进程, 此时被init进程领养,
          当孤儿进程退出之后, 就会被init进程回收.
          
僵尸进程: 子进程先退出, 父进程没有完成对子进程的回收, 此时子进程就变成了僵尸进程.
如何解决僵尸进程:
	不能使用kill -9杀死僵尸进程, 原因是僵尸进程是一个死掉的进程;
	应该使用杀死僵尸进程父进程的方法来解决僵尸进程;
	原因是: 杀死其父进程可以让init进程领养僵尸进程,最后由init进程回收僵尸进程.
	
wait函数:
	pid_t wait(int *status);
	返回值:
		>0: 回收的子进程的PID
		-1: 没有子进程
	参数:
		status: 子进程的退出状态
			if(WIFEXITED(status))
			{
				WEXITSTATUS(status)
			}
			else if(WIFSIGNALED(status))
			{
				WTERMSIG(status)
			}

waitpid函数：
pid_t waitpid(pid_t pid, int *status, int options);
    参数:
        pid:
            >0: 表示等待指定的子进程
            =-1: 表示等待任意子进程
        status:
            同wait函数
        options:
            0：表示阻塞
            WNOHANG：表示不阻塞
    返回值：
        >0：回收的子进程的PID
        =0：若options取值为WNOHANG，则表示子进程还活者
        =-1：表示已经没有子进程了

    注意：调用一次waitpid或者wait函数只能回收一个子进程。