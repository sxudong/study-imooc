package chapter10;import java.util.Timer;import java.util.TimerTask;import java.util.concurrent.*;/** * * 9.2.1 线程池的创建 * */public class ThreadPoolTest2 {    // 线程计数    private static int count = 0;    public static void main(String[] args) {        // 通常会使用一个队列，进行排序        BlockingQueue<Runnable> queue = new ArrayBlockingQueue<>(25);        // 如果使用无界的队列，当出现攻击时，容易导致内存泄漏。        //LinkedBlockingDeque<Runnable> queue = new LinkedBlockingDeque<>();        /**         * 使用给定的参数创建 ThreadPoolExecutor.         *         * @param corePoolSize    核心线程池中的最大线程数         * @param maximumPoolSize 总线程池中的最大线程数         * @param keepAliveTime   空闲线程的存活时间         * @param unit            keepAliveTime的单位         * @param workQueue       任务队列, 保存已经提交但尚未被执行的线程         * @param threadFactory   线程工厂(用于指定如果创建一个线程)         * @param handler         拒绝策略 (当任务太多导致工作队列满时的处理策略)         */        ThreadPoolExecutor pool = new ThreadPoolExecutor(5, 10, 30, TimeUnit.MINUTES, queue);        // 重写Handler抛出来的线程重新加进去        pool.setRejectedExecutionHandler(new RejectedExecutionHandler() {            @Override            public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {                // TODO Auto-generated method stub                while (true) {                    if (queue.size() < 24) {                        System.out.println("++++++++++++++Runnable");                        executor.execute(r);                        break;                    }                }            }        });        // 定义一个定时器，每2秒创建10个进程        Timer timer = new Timer();        timer.schedule(new TimerTask() {            @Override            public void run() {                for (int i = 0; i < 10; i++) {                    count++;                    doWork work = new doWork();                    pool.execute(work);                }                if (count >= 200) {                    timer.cancel();                }            }        }, 0, 2000);        // 定时检查线程的状况        new Timer().schedule(new TimerTask() {            @Override            public void run() {                // TODO Auto-generated method stub                System.err.println(">>当前队列：" + queue.size());                System.err.println(">>线程数：" + count);                System.err.println(">>当前ActiveCount：" + pool.getActiveCount());                System.err.println(">>当前TaskCount：" + pool.getTaskCount());                System.err.println(">>当前PoolSize：" + pool.getPoolSize());            }        }, 1000, 1000);    }}/* Output:>>当前队列：5>>线程数：10>>当前ActiveCount：5>>当前TaskCount：10>>当前PoolSize：5>>当前队列：5>>线程数：10>>当前ActiveCount：5>>当前TaskCount：10>>当前PoolSize：5>>当前队列：15>>线程数：20>>当前ActiveCount：5>>当前TaskCount：20>>当前PoolSize：5线程id:18 线程名称:pool-1-thread-5线程id:17 线程名称:pool-1-thread-4线程id:15 线程名称:pool-1-thread-2线程id:14 线程名称:pool-1-thread-1线程id:16 线程名称:pool-1-thread-3>>当前队列：10>>线程数：20>>当前ActiveCount：5>>当前TaskCount：20>>当前PoolSize：5...... */