package chapter08;import java.util.concurrent.CyclicBarrier;/** * 8.2 同步屏障CyclicBarrier  代码清单8-4 * * CyclicBarrier 还提供一个更高级的构造函数 CyclicBarrier（int parties，Runnable barrierAction）， * 用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景，如下代码： */public class CyclicBarrierTest2 {    static CyclicBarrier c = new CyclicBarrier(2, new A());    public static void main(String[] args) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    c.await();                } catch (Exception e) {                }                System.out.println(1);            }        }).start();        try {            c.await();        } catch (Exception e) {        }        System.out.println(2);    }    static class A implements Runnable {        @Override        public void run() {            System.out.println(3);        }    }}/* 因为 CyclicBarrier 设置了拦截线程的数量是2，所以必须等代码中的第一个线程和   线程A都执行完之后，才会继续执行主线程，然后输出2，所以代码执行后的输出如下:321 */