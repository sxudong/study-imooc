package chapter08;/** * 8.1 等待多线程完成的CountDownLatch  代码清单8-1 */public class JoinCountDownLatchTest {    public static void main(String[] args) throws InterruptedException {        Thread parser1 = new Thread(new Runnable() {            @Override            public void run() {                System.out.println("parser1 finish");            }        });        Thread parser2 = new Thread(new Runnable() {            @Override            public void run() {                System.out.println("parser2 finish");            }        });        parser1.start();        parser2.start();        // join用于让当前执行线程等待 join 线程执行结束,其实现原理是不停        // 检查 join 线程是否存活,如果 join 线程存活则让当前线程永远等待.        // join 用于让当前执行线程等待 join 线程执行结束。其实现原理是不停        // 检查 join 线程是否存活，如果 join 线程存活则让当前线程永远等待。        // 其中，wait（0）表示永远等待下去。直到 join 线程中止后，线程的        // this.notifyAll() 方法会被调用，调用 notifyAll() 方法是在 JVM        // 里实现的。        parser1.join();        parser2.join();        System.out.println("all parser finish");    }}   //在JDK 1.5之后的并发包中提供的CountDownLatch也可以实现join的功能，并且比join的功能更多/* Output:parser1 finishparser2 finishall parser finish */